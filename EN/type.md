# typeKeyword summary

### type Usage:

* Define structure
* Define the interface
* Type alias
* Type definition
* Type switch

The difference between type definition and type alias:
The difference is that the type definition completely defines a new type,
The type alias is simply an alias for the existing type. (The compiler is replaced with a basic type.)


### Type Common Demo

###### Defining Structures
```
type Demo struct {}

```

###### Define the interface
```
type Demoer interface {}

```

###### Type alias
```
type Demo string

```

###### Type definition
```
type handle func (str string)

```

###### Type aliases and type definitions (Distinction)

Define built-in type definitions prior to Go 1.9:
```
type byte uint8
type rune int32
```

After Go 1.9, it becomes:
```
type byte = uint8
type rune = int32
```
This change is made in conjunction with the type alias.

The definition of a type alias is written as:
```
type TypeAlias = Type
```
A Type alias specifies that a TypeAlias is an alias to a Type; essentially, a TypeAlias is the same Type as a Type.

```
package main
import (
"fmt"
)
// Define NewInt as int
type NewInt int
// Use an int as IntAlias
type IntAlias = int
func main() {
// Declare A as type NewInt
var a NewInt
// View the type name of A
fmt.Printf("a type: %T\n", a)
Declare A2 as type IntAlias
var a2 IntAlias
// View the type name of A2
fmt.Printf("a2 type: %T\n", a2)
}

// a type: main.NewInt
// a2 type: int

```


###### Type Switch
```
func Demo (params ... interface (}) {
   for i, x: = range params {
      switch x. (type) {
      case bool:
         fmt.Printf ("type #% d is bool", i)
      default:
         fmt.Printf ("type is unknow")
      }
   }
}

```

### Type Considerations

###### Type comparison
Remarks:
Refer to Go documentation for type description:
* Named types (simple types), there are type names such as int, int64, float, string, bool. There are also custom named types.
* Unnamed type (complex type), no type name array slice, map, func () {}, interface {}. But ** chan type is == comparable **.
   * Slice memory is not continuous, and the underlying objects are open.
   * The map memory is not continuous, and the underlying objects are stored independently.
   * chan memory is continuous, single object, can be directly compared;
* When comparing two named types, the type names must be the same; when comparing named types with unnamed types, ** the underlying types are the same **.
* The comparison is based on two principles: 1. the underlying basic type of memory; 2. whether the type itself determines the type or the unstable type;

* Null interface value comparison

```
package main

import (
"fmt"
"reflect"
)

type T1 [] string
type T2 [] string

func main () {
foo0: = [] string {}
foo1: = T1 {}
foo2: = T2 {}
fmt.Println (reflect.TypeOf (foo0))
fmt.Println (reflect.TypeOf (foo1))
fmt.Println (reflect.TypeOf (foo2))

// Output:
// [] string
// main.T1
// main.T2

// Compile pass, and vice versa
// foo1 = foo0
// foo0 = foo1

// Compile failed
// Error prompt: cannot use foo2 (type T2) as type T1 in assignment
foo2 = foo0
   foo1 = foo2 // cannot



   // Compiled by: chan
   ch1: = make (chan int)
   ch2: = make (chan int)
   fmt.Println (ch1 == ch2)
    
   // Compile failed: slice
   s1: = [] int {1,2}
   s2: = [] int {2,1}
   fmt.Println (s1 == s2)

   // Compile failed: map
   m1: = make (map [int] int)
   m2: = make (map [int] int)
   fmt.Println (m1 == m2)
}

```


###### Type Comparability

Judgment principle:
Whether the underlying data structure type is stable and consistent

| Type | Description |
|: --- |: ------------------ |
map | downtime error, not comparable |
| Slice ([] T) | Downtime error, not comparable
Channel | Comparable, must be generated by the same make, that is, the same channel will be true, otherwise false |
Array ([capacity] T) | Comparable, compile time knows if two arrays are consistent |
Structure | Comparable, you can compare structure values ​​one by one |
| Functions | Comparable