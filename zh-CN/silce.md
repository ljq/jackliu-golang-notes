# go 切片：本质

###  数组
Go的切片是在数组之上的抽象数据类型，因此在了解切片之前必须要要理解数组。
数组类型由指定和长度和元素类型定义。
数组不需要显式的初始化；数组元素会自动初始化为零值：
Go的数组是值语义。一个数组变量表示整个数组，它不是指向第一个元素的指针（比如C语言的数组）。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。（为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组。）可以将数组看作一个特殊的struct，结构的字段名对应数组的索引，同时成员的数目固定。

####  切片
数组虽然有适用它们的地方，但是数组不够灵活，因此在Go代码中数组使用的并不多。但是，切片则使用得相当广泛。切片基于数组构建，但是提供更强的功能和便利。
切片的类型是 []T，T 是切片元素的类型。和数组不同的是，切片没有固定的长度。
切片的字面值和数组字面值很像，不过切片没有指定元素个数：
切片可以内置函数 make 创建，函数签名为：
func make([]T, len, cap) []T
T 代表被创建的切片元素的类型。函数 make 接受一个类型、一个长度和一个可选的容量参数。调用 make 时，内部会分配一个数组，然后返回数组对应的切片。
当容量参数被忽略时，它默认为指定的长度。下面是简洁的写法：
s := make([]byte, 5)
可以使用内置函数 len 和 cap 获取切片的长度和容量信息。
len(s) == 5
cap(s) == 5
### 长度和容量之间的关系。
零值的切片类型变量为 nil。对于零值切片变量，len 和 cap 都将返回 0。
切片也可以基于现有的切片或数组生成。切分的范围由两个由冒号分割的索引对应的半开区间指定。
切片的开始和结束的索引都是可选的；它们分别默认为零和数组的长度。

### 切片的本质
一个切片是一个数组切割区间的描述。它包含了指向数组的指针，切割区间的长度，和容量（切割区间的最大长度）。
切片并不复制整个切片元素。它创建一个新的切片执行同样的底层数组。这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素同样会影响到原始的切片。
切片增长不能超出其容量。增长超出切片容量将会导致运行时异常，就像切片或数组的索引超出范围引起异常一样。同样，不能使用小于零的索引去访问切片之前的元素。
切片生长（复制和追加）
要增加切片的容量必须创建一个新的、更大容量的切片，然后将原有切片的内容复制到新的切片。整个技术是一些支持动态数组语言的常见实现。
循环中复制的操作可以由 copy 内置函数替代。copy 函数将源切片的元素复制到目的切片。它返回复制元素的数目。
func copy(dst, src []T) int
copy 函数支持不同长度的切片之间的复制（它只复制最小切片长度的元素）。此外，copy 函数可以正确处理源和目的切片有重叠的情况。
但大多数程序不需要完全的控制，因此Go提供了一个内置函数 append，用于大多数场合；它的函数签名：
func append(s []T, x ...T) []T 
append函数将x追加到切片s的末尾，并且在必要的时候增加容量。
如果是要将一个切片追加到另一个切片尾部，需要使用…语法将第2个参数展开为参数列表。
可以声明一个零值切片（nil），然后在循环中向切片追加数据：

可能的“陷阱”
切片操作并不会复制底层的数组。此层的数组将被保存在内存中，直到它不再被引用。有时候可能会因为一个小的内存引用导致保存所有的数据。
